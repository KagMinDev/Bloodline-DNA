import { useCallback, useEffect, useRef, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";

import { getBookingByIdApi } from "../api/bookingListApi";
import {
  confirmCollectionApi,
  confirmDeliveryApi,
  updateBookingStatusApi,
} from "../api/bookingUpdateApi";
import { callPaymentCallbackApi } from "../api/checkoutApi";
import { submitFeedbackApi } from "../api/feedbackApi";
import {
  callRemainingPaymentCallbackApi,
  checkoutPaymentApi,
  checkoutRemainingPaymentApi,
} from "../api/paymentApi";
import {
  getTestKitByBookingIdApi,
  getTestSampleByKitIdApi,
} from "../api/sampleApi";
import { getUserInfoApi } from "../api/userApi";
import {
  generateProgressData,
  transformApiDataToBookingDetail,
} from "../components/utils/bookingUtils";
import type {
  BookingDetail,
  DetailedBookingStatus,
  TestProgressData,
} from "../types/bookingTypes";
import { useExistingFeedback } from "./useExistingFeedback";

const statusNumberMapping: Record<number, DetailedBookingStatus> = {
  0: "Pending",
  1: "PreparingKit",
  2: "DeliveringKit",
  3: "KitDelivered",
  4: "WaitingForSample",
  5: "ReturningSample",
  6: "SampleReceived",
  7: "Testing",
  8: "Completed",
  9: "Cancelled",
  10: "StaffGettingSample",
  11: "CheckIn",
};

const isDetailedBookingStatus = (
  status: any
): status is DetailedBookingStatus =>
  Object.values(statusNumberMapping).includes(status);

export const useBookingData = () => {
  const [booking, setBooking] = useState<BookingDetail | null>(null);
  const [progressData, setProgressData] = useState<TestProgressData | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [paymentLoading, setPaymentLoading] = useState(false);
  const [paymentError, setPaymentError] = useState<string | null>(null);
  const [paymentStatus, setPaymentStatus] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [testServiceId, setTestServiceId] = useState<string | null>(null);
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState("");
  const [isSubmittingFeedback, setIsSubmittingFeedback] = useState(false);
  const [feedbackSuccess, setFeedbackSuccess] = useState<string | null>(null);
  const [feedbackError, setFeedbackError] = useState<string | null>(null);
  const [isSampleModalOpen, setIsSampleModalOpen] = useState(false);
  const [confirmDeliveryLoading, setConfirmDeliveryLoading] = useState(false);
  const [shouldShowSampleButton, setShouldShowSampleButton] = useState(true);
  const [hasSampleInfo, setHasSampleInfo] = useState<boolean | undefined>(
    undefined
  );
  const [isDeliveryConfirmed, setIsDeliveryConfirmed] = useState(false);
  const [isCollectionConfirmed, setIsCollectionConfirmed] = useState(false);
  const [isCollectionModalOpen, setIsCollectionModalOpen] = useState(false);
  const [collectionLoading, setCollectionLoading] = useState(false);
  const [isErrorModalOpen, setIsErrorModalOpen] = useState(false);
  const [errorModalMessage, setErrorModalMessage] = useState<string>("");
  // Use existing feedback hook
  const { checkExistingFeedback, getExistingFeedback, isCheckingFeedbackFor, clearFeedbackCache } =
    useExistingFeedback();

  const { id: bookingId } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const hasProcessedCallback = useRef(false);

  // Clear feedback cache khi bookingId thay ƒë·ªïi ƒë·ªÉ tr√°nh hi·ªÉn th·ªã feedback sai
  useEffect(() => {
    if (bookingId) {
      console.log(`üßπ Clearing feedback cache for new bookingId: ${bookingId}`);
      clearFeedbackCache();
    }
  }, [bookingId, clearFeedbackCache]);

  const checkSampleInfoStatus = useCallback(async (bookingId: string) => {
    try {

      // First get the TestKit ID
      const testKitResponse = await getTestKitByBookingIdApi(bookingId);
      if (!testKitResponse.success || !testKitResponse.data?.id) {
        setShouldShowSampleButton(true);
        return;
      }

      const kitId = testKitResponse.data.id;

      // Check if TestSample exists for this kit
      const testSampleResponse = await getTestSampleByKitIdApi(kitId);
      if (testSampleResponse.success && testSampleResponse.data) {
        setShouldShowSampleButton(false);
        setHasSampleInfo(true);
      } else {
        setShouldShowSampleButton(true);
        setHasSampleInfo(false);
      }
    } catch (error) {
      console.error("‚ùå Error checking sample info status:", error);
      // On error, show the button to be safe
      setShouldShowSampleButton(true);
      setHasSampleInfo(false);
    }
  }, []);

  const fetchBookingData = useCallback(async () => {
    if (!bookingId) {
      setError("Booking ID kh√¥ng h·ª£p l·ªá");
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      const [apiData, userData] = await Promise.all([
        getBookingByIdApi(bookingId),
        getUserInfoApi().catch(() => null),
      ]);

      if (userData?.id) setUserId(userData.id);
      if (!apiData) throw new Error("Kh√¥ng t√¨m th·∫•y th√¥ng tin booking");

      const formatted = transformApiDataToBookingDetail(
        apiData,
        setTestServiceId
      );
      setBooking(formatted);
      // Generate progress data with sample info status
      setProgressData(generateProgressData(formatted, hasSampleInfo));

      const rawStatus = formatted.status;
      let normalizedStatus: DetailedBookingStatus | null = null;

      if (typeof rawStatus === "number") {
        normalizedStatus = statusNumberMapping[rawStatus];
      } else if (isDetailedBookingStatus(rawStatus)) {
        normalizedStatus = rawStatus;
      }

      if (
        normalizedStatus === "PreparingKit" ||
        normalizedStatus === "Completed"
      ) {
        setPaymentStatus("PAID");
      } else if (normalizedStatus === "Cancelled") {
        setPaymentError("Thanh to√°n th·∫•t b·∫°i");
      }

      // Check if delivery has been confirmed for this booking
      const deliveryConfirmKey = `delivery_confirmed_${bookingId}`;
      const isDeliveryConfirmed =
        localStorage.getItem(deliveryConfirmKey) === "true";
      setIsDeliveryConfirmed(isDeliveryConfirmed);

      // Check if collection has been confirmed for this booking
      const collectionConfirmKey = `collection_confirmed_${bookingId}`;
      const isCollectionConfirmed =
        localStorage.getItem(collectionConfirmKey) === "true";
      setIsCollectionConfirmed(isCollectionConfirmed);

      // Check if sample info has been submitted for WaitingForSample status
      if (normalizedStatus === "WaitingForSample") {
        await checkSampleInfoStatus(bookingId);
      } else {
        setShouldShowSampleButton(true); // Show button for other statuses
        setHasSampleInfo(undefined); // Reset for other statuses
      }

      // Check existing feedback if status is Completed
      // Note: testServiceId will be checked in a separate useEffect after it's set
    } catch (err) {
      const msg =
        err instanceof Error ? err.message : "L·ªói khi t·∫£i th√¥ng tin ƒë·∫∑t l·ªãch";
      setError(msg);
      setBooking(null);
      if (msg.includes("Kh√¥ng t√¨m th·∫•y")) {
        setTimeout(() => navigate("/booking-list"), 3000);
      }
    } finally {
      setIsLoading(false);
    }
  }, [bookingId, navigate]);

  useEffect(() => {
    fetchBookingData();
  }, [fetchBookingData]);

  // Regenerate progress data when sample info status changes
  useEffect(() => {
    if (booking) {
      setProgressData(generateProgressData(booking, hasSampleInfo));
    }
  }, [booking, hasSampleInfo]);

  // Check existing feedback after testServiceId and userId are set
  useEffect(() => {
    if (booking?.status === "Completed" && userId && testServiceId) {
      console.log("üîÑ Checking existing feedback for:", {
        userId,
        testServiceId,
        bookingId,
        bookingStatus: booking?.status
      });
      
      // Validation: ƒê·∫£m b·∫£o testServiceId thu·ªôc v·ªÅ booking hi·ªán t·∫°i
      if (testServiceId && bookingId) {
        checkExistingFeedback(userId, testServiceId);
      } else {
        console.warn("‚ö†Ô∏è Missing testServiceId or bookingId for feedback check");
      }
    }
  }, [booking?.status, userId, testServiceId, bookingId, checkExistingFeedback]);

  const handlePayment = async (payload?: any) => {
    if (!booking?.id) {
      setPaymentError("Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë·∫∑t l·ªãch");
      return;
    }

    setPaymentLoading(true);
    setPaymentError(null);

    try {
      const isRemaining = payload?.type === "remaining";
      const result = isRemaining
        ? await checkoutRemainingPaymentApi(booking.id)
        : await checkoutPaymentApi(booking.id);

      if (!result.success)
        throw new Error(result.message || "Kh√¥ng th·ªÉ t·∫°o link thanh to√°n");

      const paymentData = {
        orderCode: result.orderCode,
        bookingId: booking.id,
        isRemainingPayment: isRemaining,
        timestamp: new Date().toISOString(),
      };

      localStorage.setItem("paymentData", JSON.stringify(paymentData));
      if (result.paymentUrl || result.checkoutUrl) {
        window.location.href = result.paymentUrl || result.checkoutUrl;
      } else {
        setPaymentStatus("PAID");
      }
    } catch (err) {
      setPaymentError(
        err instanceof Error ? err.message : "L·ªói thanh to√°n kh√¥ng x√°c ƒë·ªãnh"
      );
    } finally {
      setPaymentLoading(false);
    }
  };

  const handlePaymentCallback = useCallback(
    async (orderCode: string, status: string) => {
      try {
        const paymentDataStr = localStorage.getItem("paymentData");
        const paymentData = paymentDataStr ? JSON.parse(paymentDataStr) : null;
        const effectiveBookingId = paymentData?.bookingId || bookingId;
        if (!effectiveBookingId) throw new Error("Kh√¥ng t√¨m th·∫•y bookingId");

        const normalizedStatus =
          status.toUpperCase() === "PAID" ? "PAID" : "CANCELLED";

        // Check if this is a remaining payment
        const isRemainingPayment = paymentData?.isRemainingPayment || false;

        // console.log("üîÑ Processing payment callback:", {
        //   orderCode,
        //   status: normalizedStatus,
        //   bookingId: effectiveBookingId,
        //   isRemainingPayment,
        //   timestamp: new Date().toISOString(),
        // });

        // Use the appropriate callback API based on payment type
        const response = isRemainingPayment
          ? await callRemainingPaymentCallbackApi({
              orderCode,
              status: normalizedStatus,
              bookingId: effectiveBookingId,
            })
          : await callPaymentCallbackApi({
              orderCode,
              status: normalizedStatus,
              bookingId: effectiveBookingId,
            });

        if (response.success && response.status === "PAID") {
          setPaymentStatus("PAID");
          // console.log("‚úÖ Payment callback successful:", {
          //   paymentType: isRemainingPayment ? "remaining" : "deposit",
          //   orderCode,
          //   bookingId: effectiveBookingId,
          //   timestamp: new Date().toISOString(),
          // });
        } else {
          setPaymentStatus("CANCELLED");
          setPaymentError("Thanh to√°n th·∫•t b·∫°i ho·∫∑c b·ªã h·ªßy");
          // console.log("‚ùå Payment callback failed:", {
          //   paymentType: isRemainingPayment ? "remaining" : "deposit",
          //   orderCode,
          //   bookingId: effectiveBookingId,
          //   response,
          //   timestamp: new Date().toISOString(),
          // });
        }

        await fetchBookingData();
        localStorage.removeItem("paymentData");
        return true;
      } catch (err) {
        console.error("‚ùå Callback Error:", err);
        setPaymentError("L·ªói callback thanh to√°n");
        return false;
      }
    },
    [bookingId, fetchBookingData]
  );

  useEffect(() => {
    const processPaymentReturn = async () => {
      // ‚ùå N·∫øu ƒë√£ x·ª≠ l√Ω callback, kh√¥ng x·ª≠ l√Ω l·∫°i n·ªØa
      if (hasProcessedCallback.current) return;

      const params = new URLSearchParams(window.location.search);
      const status = params.get("status");
      const orderCode = params.get("orderCode") || params.get("exportCode");
      if (!status || !orderCode) return;

      hasProcessedCallback.current = true; // ‚úÖ ƒë√°nh d·∫•u l√† ƒë√£ x·ª≠ l√Ω

      const success = await handlePaymentCallback(orderCode, status);
      if (success) {
        params.delete("status");
        params.delete("orderCode");
        params.delete("exportCode");
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, "", newUrl);
      }
    };

    processPaymentReturn();
  }, [handlePaymentCallback]);

  const handleFeedbackSubmit = async () => {
    if (!userId || !testServiceId) {
      setFeedbackError("Thi·∫øu th√¥ng tin ng∆∞·ªùi d√πng ho·∫∑c d·ªãch v·ª•");
      return;
    }
    if (rating === 0) {
      setFeedbackError("Vui l√≤ng ch·ªçn s·ªë sao ƒë√°nh gi√°");
      return;
    }

    setIsSubmittingFeedback(true);
    setFeedbackError(null);

    try {
      const res = await submitFeedbackApi({
        userId,
        testServiceId,
        rating,
        comment,
      });
      if (res.success) {
        setFeedbackSuccess("G·ª≠i ƒë√°nh gi√° th√†nh c√¥ng!");
        setRating(0);
        setComment("");
      } else {
        throw new Error(res.message);
      }
    } catch (err) {
      setFeedbackError(
        err instanceof Error ? err.message : "L·ªói khi g·ª≠i ƒë√°nh gi√°"
      );
    } finally {
      setIsSubmittingFeedback(false);
    }
  };

  const handleSampleSubmitSuccess = async () => {
    console.log(
      "‚úÖ Sample info submitted successfully, updating sample status"
    );
    setIsSampleModalOpen(false);
    // Update sample info status immediately
    setShouldShowSampleButton(false);
    setHasSampleInfo(true);
    // Also refresh booking data for any other changes
    await fetchBookingData();
  };

  const handleConfirmDelivery = async (bookingId: string) => {
    if (!bookingId) {
      console.error("Booking ID is required for confirm delivery");
      return;
    }

    setConfirmDeliveryLoading(true);
    try {
      const result = await confirmDeliveryApi(bookingId);

      // // Log chi ti·∫øt response t·ª´ API
      // console.log("üì• API Response:", {
      //   success: result.success,
      //   message: result.message,
      //   statusCode: result.statusCode,
      //   data: result.data,
      // });

      if (result.success) {

        // Save delivery confirmation status to localStorage
        const deliveryConfirmKey = `delivery_confirmed_${bookingId}`;
        localStorage.setItem(deliveryConfirmKey, "true");

        // Update local state immediately
        setIsDeliveryConfirmed(true);

        // Ngay l·∫≠p t·ª©c g·ªçi updateBookingStatusApi v·ªõi newStatus=4 (WaitingForSample)
        try {
          console.log("üîÑ Updating booking status to WaitingForSample (status 4)...");
          const statusUpdateResult = await updateBookingStatusApi(bookingId, 4);

          if (statusUpdateResult.success) {
            console.log("‚úÖ Booking status updated to WaitingForSample successfully");
            
            // Refresh booking data to get updated status
            await fetchBookingData();
          } else {
            console.warn("‚ö†Ô∏è Failed to update booking status:", statusUpdateResult.message);
            // V·∫´n hi·ªÉn th·ªã th√†nh c√¥ng cho user v√¨ confirm delivery ƒë√£ th√†nh c√¥ng
            // Ch·ªâ log warning ƒë·ªÉ kh√¥ng l√†m user b·ªëi r·ªëi
          }
        } catch (statusError) {
          console.error("‚ùå Error updating booking status:", statusError);
          // Kh√¥ng throw error ·ªü ƒë√¢y v√¨ confirm delivery ƒë√£ th√†nh c√¥ng
          // Ch·ªâ log error v√† ti·∫øp t·ª•c
        }
      } else {
        throw new Error(result.message || "Failed to confirm delivery");
      }
    } catch (err) {
      console.error("‚ùå Error confirming delivery:", err);
      
      // Hi·ªÉn th·ªã th√¥ng b√°o th√¢n thi·ªán cho user
      let userFriendlyMessage = "H·ªá th·ªëng ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t, vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t";
      
      // Ki·ªÉm tra c√°c lo·∫°i l·ªói c·ª• th·ªÉ
      if (err instanceof Error) {
        const errorMessage = err.message.toLowerCase();
        
        // L·ªói 400 Bad Request
        if (errorMessage.includes("400") || errorMessage.includes("bad request")) {
          userFriendlyMessage = "H·ªá th·ªëng ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t, vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t";
        }
        // L·ªói 401 Unauthorized
        else if (errorMessage.includes("401") || errorMessage.includes("unauthorized")) {
          userFriendlyMessage = "Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i";
        }
        // L·ªói 403 Forbidden
        else if (errorMessage.includes("403") || errorMessage.includes("forbidden")) {
          userFriendlyMessage = "B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán thao t√°c n√†y";
        }
        // L·ªói 404 Not Found
        else if (errorMessage.includes("404") || errorMessage.includes("not found")) {
          userFriendlyMessage = "Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë∆°n h√†ng";
        }
        // L·ªói 500 Server Error
        else if (errorMessage.includes("500") || errorMessage.includes("server error")) {
          userFriendlyMessage = "H·ªá th·ªëng ƒëang b·∫£o tr√¨, vui l√≤ng th·ª≠ l·∫°i sau";
        }
        // L·ªói network
        else if (errorMessage.includes("network") || errorMessage.includes("fetch")) {
          userFriendlyMessage = "L·ªói k·∫øt n·ªëi m·∫°ng, vui l√≤ng ki·ªÉm tra internet v√† th·ª≠ l·∫°i";
        }
      }
      
      // Kh√¥ng set error state ch√≠nh ƒë·ªÉ tr√°nh trigger error boundary
      // Ch·ªâ set error modal ƒë·ªÉ hi·ªÉn th·ªã popup
      console.log('üö® Setting error modal:', userFriendlyMessage);
      setErrorModalMessage(userFriendlyMessage);
      setIsErrorModalOpen(true);
    } finally {
      setConfirmDeliveryLoading(false);
    }
  };

  const handleConfirmCollection = async (dateTime: string) => {
    if (!bookingId) {
      console.error("Booking ID is required for confirm collection");
      return;
    }

    setCollectionLoading(true);
    try {
      // console.log(
      //   "üîÑ Confirming collection for booking:",
      //   bookingId,
      //   "at:",
      //   dateTime
      // );
      const result = await confirmCollectionApi(bookingId, dateTime);

      if (result.success) {
        // Save collection confirmation status to localStorage
        const collectionConfirmKey = `collection_confirmed_${bookingId}`;
        localStorage.setItem(collectionConfirmKey, "true");

        // Update local state immediately
        setIsCollectionConfirmed(true);
        setIsCollectionModalOpen(false);

        // Refresh booking data to get updated status
        await fetchBookingData();
      } else {
        throw new Error(result.message || "Failed to confirm collection");
      }
    } catch (err) {
      console.error("‚ùå Error confirming collection:", err);
      const errorMessage =
        err instanceof Error ? err.message : "L·ªói x√°c nh·∫≠n l·ªãch l·∫•y m·∫´u";
      setError(errorMessage);
    } finally {
      setCollectionLoading(false);
    }
  };

  const handleStepAction = (payload: any) => {
    switch (payload?.type) {
      case "deposit":
      case "remaining":
        handlePayment(payload);
        break;
      case "fill_sample_info":
        setIsSampleModalOpen(true);
        break;
      case "confirmKitReceived":
        if (booking?.id) {
          handleConfirmDelivery(booking.id);
        } else {
          console.error("Kh√¥ng t√¨m th·∫•y booking ID ƒë·ªÉ x√°c nh·∫≠n nh·∫≠n Kit");
        }
        break;
      case "schedule_collection":
        setIsCollectionModalOpen(true);
        break;
      default:
        console.warn("H√†nh ƒë·ªông kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£:", payload?.type);
    }
  };

  return {
    booking,
    progressData,
    isLoading,
    error,
    paymentLoading,
    paymentError,
    paymentStatus,
    userId,
    testServiceId,
    rating,
    setRating,
    comment,
    setComment,
    isSubmittingFeedback,
    feedbackSuccess,
    feedbackError,
    isSampleModalOpen,
    setIsSampleModalOpen,
    confirmDeliveryLoading,
    shouldShowSampleButton,
    isDeliveryConfirmed,
    isCollectionConfirmed,
    isCollectionModalOpen,
    setIsCollectionModalOpen,
    collectionLoading,
    isErrorModalOpen,
    setIsErrorModalOpen,
    errorModalMessage,
    getExistingFeedback,
    isCheckingFeedbackFor,
    handlePayment,
    handleFeedbackSubmit,
    handleSampleSubmitSuccess,
    handlePaymentCallback,
    handleStepAction,
    handleConfirmDelivery,
    handleConfirmCollection,
    navigate,
    refetchBookingData: fetchBookingData,
  };
};
