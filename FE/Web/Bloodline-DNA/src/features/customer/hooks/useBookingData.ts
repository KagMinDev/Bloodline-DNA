import { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { getBookingByIdApi } from '../api/bookingListApi';
import { checkoutPaymentApi, checkoutRemainingPaymentApi } from '../api/paymentApi';
import { submitFeedbackApi } from '../api/feedbackApi';
import { getUserInfoApi } from '../api/userApi';
import type { BookingDetail, TestProgressData } from '../types/bookingTypes';
import { generateProgressData, transformApiDataToBookingDetail } from '../components/utils/bookingUtils';
import { updateErrorStatusApi, updateSuccessStatusApi } from '../api/checkoutApi';
import { paymentLogger } from '../utils/paymentLogger';

export const useBookingData = () => {
  const [booking, setBooking] = useState<BookingDetail | null>(null);
  const [progressData, setProgressData] = useState<TestProgressData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [paymentLoading, setPaymentLoading] = useState(false);
  const [paymentError, setPaymentError] = useState<string | null>(null);
  const [paymentStatus, setPaymentStatus] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [testServiceId, setTestServiceId] = useState<string | null>(null);
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');
  const [isSubmittingFeedback, setIsSubmittingFeedback] = useState(false);
  const [feedbackSuccess, setFeedbackSuccess] = useState<string | null>(null);
  const [feedbackError, setFeedbackError] = useState<string | null>(null);
  const [isSampleModalOpen, setIsSampleModalOpen] = useState(false);
  const { id: bookingId } = useParams<{ id: string }>();
  const navigate = useNavigate();

  const fetchBookingData = useCallback(async () => {
    if (!bookingId) {
      setError('Booking ID kh√¥ng h·ª£p l·ªá');
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      // Fetch song song booking info v√† user info
      const [apiData, userData] = await Promise.all([
        getBookingByIdApi(bookingId).catch(err => {
          console.error('Error fetching booking:', err);
          throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n ƒë·∫∑t l·ªãch');
        }),
        getUserInfoApi().catch(() => null) // B·ªè qua l·ªói n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c user info
      ]);

      // X·ª≠ l√Ω user data
      if (userData?.id) {
        setUserId(userData.id);
      }

      // X·ª≠ l√Ω booking data
      if (!apiData) {
        throw new Error('Kh√¥ng t√¨m th·∫•y th√¥ng tin booking');
      }

      const formattedBooking = transformApiDataToBookingDetail(apiData, setTestServiceId);
      setBooking(formattedBooking);
      
      const progress = generateProgressData(formattedBooking);
      setProgressData(progress);

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n
      if (formattedBooking.status === 'confirmed' || formattedBooking.status === 'completed') {
        setPaymentStatus('PAID');
      } else if (formattedBooking.status === 'cancelled') {
        setPaymentError('Thanh to√°n th·∫•t b·∫°i');
      }

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'L·ªói khi t·∫£i th√¥ng tin ƒë·∫∑t l·ªãch';
      setError(errorMessage);
      setBooking(null);
      
      // N·∫øu kh√¥ng t√¨m th·∫•y booking, ƒëi·ªÅu h∆∞·ªõng sau 3 gi√¢y
      if (errorMessage.includes('Kh√¥ng t√¨m th·∫•y')) {
        setTimeout(() => navigate('/booking-list'), 3000);
      }
    } finally {
      setIsLoading(false);
    }
  }, [bookingId, navigate]);

  // Kh·ªüi t·∫°o v√† theo d√µi booking data
  useEffect(() => {
    fetchBookingData();
  }, [fetchBookingData]);

  // X·ª≠ l√Ω thanh to√°n
  const handlePayment = async (payload?: any) => {
  console.log('üí≥ Starting payment process in useBookingData:', {
    bookingId: booking?.id,
    payload: payload,
    bookingStatus: booking?.status,
    timestamp: new Date().toISOString()
  });

  if (!booking?.id) {
    console.error('‚ùå No booking ID available for payment');
    setPaymentError('Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë·∫∑t l·ªãch');
    return;
  }

  setPaymentLoading(true);
  setPaymentError(null);

  try {
    const isRemainingPayment = payload?.type === 'remaining' || booking.status === 'finalpayment';

    console.log('üîÑ Payment type determined:', {
      isRemainingPayment: isRemainingPayment,
      payloadType: payload?.type,
      bookingStatus: booking.status,
      timestamp: new Date().toISOString()
    });

    const result = isRemainingPayment
      ? await checkoutRemainingPaymentApi(booking.id)
      : await checkoutPaymentApi(booking.id);

    console.log('üì¶ Payment API result:', {
      success: result.success,
      hasPaymentUrl: !!result.paymentUrl,
      hasCheckoutUrl: !!result.checkoutUrl,
      orderCode: result.orderCode,
      message: result.message,
      timestamp: new Date().toISOString()
    });

    if (!result.success) {
      throw new Error(result.message || 'Kh√¥ng th·ªÉ t·∫°o link thanh to√°n');
    }

    if (result.paymentUrl) {
      const redirectData = {
        url: result.paymentUrl,
        orderCode: result.orderCode,
        bookingId: booking.id,
        paymentType: isRemainingPayment ? 'remaining' as const : 'deposit' as const
      };

      console.log('üîó Redirecting to paymentUrl:', {
        ...redirectData,
        timestamp: new Date().toISOString()
      });

      paymentLogger.logPaymentRedirect(result.paymentUrl, redirectData);

      // L∆∞u th√¥ng tin orderCode v√†o sessionStorage ƒë·ªÉ x·ª≠ l√Ω callback khi quay l·∫°i
      if (result.orderCode) {
        const pendingPayment = {
          orderCode: result.orderCode,
          bookingId: booking.id,
          isRemainingPayment,
          timestamp: new Date().toISOString()
        };
        sessionStorage.setItem('pendingPayment', JSON.stringify(pendingPayment));
        console.log('üíæ Saved pending payment to sessionStorage:', pendingPayment);
      }
      window.location.href = result.paymentUrl;
    } else if (result.checkoutUrl) {
      console.log('üîó Redirecting to checkoutUrl:', {
        url: result.checkoutUrl,
        orderCode: result.orderCode,
        timestamp: new Date().toISOString()
      });

      if (result.orderCode) {
        const pendingPayment = {
          orderCode: result.orderCode,
          bookingId: booking.id,
          isRemainingPayment,
          timestamp: new Date().toISOString()
        };
        sessionStorage.setItem('pendingPayment', JSON.stringify(pendingPayment));
        console.log('üíæ Saved pending payment to sessionStorage:', pendingPayment);
      }
      window.location.href = result.checkoutUrl;
    } else {
      console.log('‚úÖ Payment completed without redirect');
      setPaymentStatus('PAID');
    }
  } catch (err) {
    console.error('‚ùå Payment error in useBookingData:', {
      error: err,
      bookingId: booking.id,
      timestamp: new Date().toISOString()
    });

    const errorMessage = err instanceof Error ? err.message : 'L·ªói thanh to√°n kh√¥ng x√°c ƒë·ªãnh';
    setPaymentError(errorMessage.includes('Kh√¥ng t√¨m th·∫•y')
      ? 'ƒê∆°n ƒë·∫∑t l·ªãch kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã h·ªßy'
      : errorMessage);
  } finally {
    setPaymentLoading(false);
  }
};

const handlePaymentCallback = useCallback(async (orderCode: string, isSuccess: boolean) => {
  console.log('üîÑ Processing payment callback:', {
    orderCode: orderCode,
    isSuccess: isSuccess,
    bookingId: bookingId,
    timestamp: new Date().toISOString()
  });

  if (!bookingId) {
    console.error('‚ùå No booking ID available for callback');
    return;
  }

  try {
    console.log('üìû Calling payment callback API:', {
      orderCode: orderCode,
      isSuccess: isSuccess,
      apiCall: isSuccess ? 'updateSuccessStatusApi' : 'updateErrorStatusApi',
      timestamp: new Date().toISOString()
    });

    const response = isSuccess
      ? await updateSuccessStatusApi(orderCode, bookingId)
      : await updateErrorStatusApi(orderCode, 'FAILED', bookingId);

    console.log('üì¶ Payment callback API response:', {
      success: response.success,
      error: response.error,
      timestamp: new Date().toISOString()
    });

    if (!response.success) {
      console.error('‚ùå Callback failed:', response.error?.message);
      return;
    }

    console.log('‚úÖ Payment callback successful, refreshing booking data');
    // Refresh booking data after successful callback
    await fetchBookingData();
  } catch (err) {
    console.error('‚ùå Error processing payment callback:', {
      error: err,
      orderCode: orderCode,
      isSuccess: isSuccess,
      timestamp: new Date().toISOString()
    });
  }
}, [bookingId, fetchBookingData]);

useEffect(() => {
  const checkPendingPayment = async () => {
    console.log('üîç Checking for pending payment in sessionStorage');

    const pendingPaymentStr = sessionStorage.getItem('pendingPayment');
    if (!pendingPaymentStr) {
      console.log('üì≠ No pending payment found in sessionStorage');
      return;
    }

    console.log('üìÑ Found pending payment in sessionStorage:', pendingPaymentStr);

    const pendingPayment = JSON.parse(pendingPaymentStr);
    if (!pendingPayment.orderCode || !pendingPayment.bookingId) {
      console.log('‚ùå Invalid pending payment data:', pendingPayment);
      return;
    }

    console.log('‚úÖ Valid pending payment data:', {
      orderCode: pendingPayment.orderCode,
      bookingId: pendingPayment.bookingId,
      isRemainingPayment: pendingPayment.isRemainingPayment,
      timestamp: pendingPayment.timestamp
    });

    // Ki·ªÉm tra URL hi·ªán t·∫°i c√≥ ch·ª©a th√¥ng b√°o th√†nh c√¥ng/kh√¥ng th√†nh c√¥ng kh√¥ng
    const searchParams = new URLSearchParams(window.location.search);
    const status = searchParams.get('status');

    console.log('üîç Checking URL status parameter:', {
      status: status,
      fullUrl: window.location.href,
      searchParams: searchParams.toString(),
      timestamp: new Date().toISOString()
    });

    if (status === 'success' || status === 'cancel') {
      const returnData = {
        status: status,
        isSuccess: status === 'success',
        orderCode: pendingPayment.orderCode,
        bookingId: pendingPayment.bookingId,
        paymentType: pendingPayment.isRemainingPayment ? 'remaining' as const : 'deposit' as const
      };

      console.log('üéØ Payment status detected, processing callback:', {
        ...returnData,
        timestamp: new Date().toISOString()
      });

      paymentLogger.logPaymentReturn(returnData);

      try {
        await handlePaymentCallback(
          pendingPayment.orderCode,
          status === 'success'
        );

        console.log('üóëÔ∏è Removing pending payment from sessionStorage');
        // X√≥a th√¥ng tin pending payment sau khi x·ª≠ l√Ω
        sessionStorage.removeItem('pendingPayment');

        // X√≥a tham s·ªë status t·ª´ URL
        searchParams.delete('status');
        const newUrl = `${window.location.pathname}?${searchParams.toString()}`;
        console.log('üîÑ Updating URL:', {
          oldUrl: window.location.href,
          newUrl: newUrl,
          timestamp: new Date().toISOString()
        });
        window.history.replaceState({}, '', newUrl);
      } catch (err) {
        console.error('‚ùå Error handling payment callback:', {
          error: err,
          pendingPayment: pendingPayment,
          status: status,
          timestamp: new Date().toISOString()
        });
      }
    } else {
      console.log('‚è≥ No payment status in URL, keeping pending payment for later check');
    }
  };

  checkPendingPayment();
}, [handlePaymentCallback]);

  // C√°c h√†m x·ª≠ l√Ω feedback v√† sample info gi·ªØ nguy√™n
  const handleFeedbackSubmit = async () => {
    if (!userId || !testServiceId) {
      setFeedbackError('Thi·∫øu th√¥ng tin ng∆∞·ªùi d√πng ho·∫∑c d·ªãch v·ª•');
      return;
    }
    if (rating === 0) {
      setFeedbackError('Vui l√≤ng ch·ªçn s·ªë sao ƒë√°nh gi√°');
      return;
    }

    setIsSubmittingFeedback(true);
    setFeedbackError(null);

    try {
      const response = await submitFeedbackApi({ userId, testServiceId, rating, comment });
      if (response.success) {
        setFeedbackSuccess('G·ª≠i ƒë√°nh gi√° th√†nh c√¥ng!');
        setComment('');
        setRating(0);
      } else {
        throw new Error(response.message);
      }
    } catch (err) {
      setFeedbackError(err instanceof Error ? err.message : 'L·ªói khi g·ª≠i ƒë√°nh gi√°');
    } finally {
      setIsSubmittingFeedback(false);
    }
  };

  const handleSampleSubmitSuccess = async () => {
    setIsSampleModalOpen(false);
    await fetchBookingData(); // Refresh data
  };

  const handleStepAction = (payload: any) => {
    if (!payload?.type) return;

    switch (payload.type) {
      case 'deposit':
      case 'remaining':
        handlePayment(payload);
        break;
      case 'fill_sample_info':
        setIsSampleModalOpen(true);
        break;
      default:
        console.warn('H√†nh ƒë·ªông kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£:', payload.type);
    }
  };

  return {
    booking,
    progressData,
    isLoading,
    error,
    paymentLoading,
    paymentError,
    paymentStatus,
    userId,
    testServiceId,
    rating,
    setRating,
    comment,
    setComment,
    isSubmittingFeedback,
    feedbackSuccess,
    feedbackError,
    isSampleModalOpen,
    setIsSampleModalOpen,
    handlePayment,
    handleFeedbackSubmit,
    handleSampleSubmitSuccess,
    handlePaymentCallback,
    handleStepAction,
    navigate,
    refetchBookingData: fetchBookingData,
  };
};